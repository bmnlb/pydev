#! /usr/bin/env python3
'''
cb-fcopy.py
ClipBoard - File Copy
------------
takes a plaintext file arg.
copies the text in the file
to the clipboard.
Not robust; some assumptions
are made about files and their
content because of how i use
the script for own purposes.
for example, it only copies
the first line in a file with
read(), because, typically, i
only need to copy the first,
single line from a file
when i use this script.
hope that makes sense.
'''
import os,sys,pyperclip

if len(sys.argv) == 2:
	argPath = sys.argv[1]

	# if arg is not an absolute path, make it so.
	if not os.path.isabs(argPath):
		argPath = os.path.join(os.getcwd(),argPath)

	print('current dir: '+os.getcwd())
	print('target file: '+argPath)

	if not os.path.isfile(argPath):
		print('file not found')
	else:
		rfile = open(argPath,mode='r')

		if not rfile.readable():
			print('file not readable')
		else:
			#using read() over readlines() because,
			#i usually just need to copy a single line.
			fileString = rfile.read()
			rfile.close()

			# remove trailing newline char and copy to cb.
			#fileStringF = fileString[:(len(fileString)-1)]
			# commented this out because it assumed the
			# final element in the string was a \n;
			# which, most of the time, it was, but
			# still unproper. the following code
			# actually checks that it is a \n char,
			# and strips it if, and only if, it is.
			fileStringF = ''
			for n in fileString:
				if n != '\n':
					fileStringF += n
			pyperclip.copy(fileStringF)

			# DEBUG output: print a sitrep.
			#print('------------------------------\n::COPIED TO CLIPBOARD:\n'+fileStringF)
			print('------------------------------\n::Number of chars copied to the clipboard: '+str(len(fileStringF)))
else:
	print('invalid arg(s). clipboard unmodified.')
